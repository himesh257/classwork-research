Let C[v] denotes the points of node v.

Let node 1 be the root node of tree. Let us define our DP dp V as the answer for subtree of node V, then our final answer is 1066963becc90d775b7d3ed08effb0181a9f3c52.

Now, we have to make a decision about including node V in our subset or not. Note that, if we include node V, we can't include any of its children(say v1, v2, ..., vn), but we can include any grand child of V. If we don't include V, we can include any child of V.

So, we can write a recursion by defining maximum of two cases.
dp(V) = max( {–, dp(vi),Cy+(<- sum of dp(j) for all children j of v;)) .

We define two DPs, dpl(V) and dp2(V), denoting maximum coins possible by choosing nodes from subtree of node V and if we include node V in our answer or not, respectively. Thus, our final answer is maximum of two case i.e. max(dp1(1) + dp2(1).

And defining recursion is even easier in this case. dp1(V) = Cy + -, dp2(v;)(since we cannot include any of the children) and dp2(V) = <max(dpl(vi), dp2(v;))(since we can include children now, but we can also choose not include them in subset, hence max of both cases).

The pseudo-code is as follows:

// adj[i] contains all pointer to linked-list of all neighbors of i

//functions as defined above
int dp1[N],dp2[N];

//pV is parent of node V
void dfs(int V, int pV){

    //for storing sums of dp1 and max(dp1, dp2) for all children of V
    int sum1=0, sum2=0;

    //traverse over all children
    for each children v of node V:
    if(v == pV) continue;
    dfs(v, V);
    sum1 += dp2[v];
    sum2 += max(dp1[v], dp2[v]);
    }

    dp1[V] = C[V] + sum1;
    dp2[V] = sum2;
}
Call the function dfs(1,0)

Thus, the final answer will be: max( dp[1], dp[2])

Time complexity is O(N).