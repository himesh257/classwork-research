
R version 3.6.2 (2019-12-12) -- "Dark and Stormy Night"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> #install.packages(c("cluster", "rattle","NbClust","psych"))
> library(datasets)
> library(ggplot2)
Warning message:
package ‘ggplot2’ was built under R version 3.6.3 
> library(cluster)
> library(rattle)
Rattle: A free graphical interface for data science with R.
Version 5.3.0 Copyright (c) 2006-2018 Togaware Pty Ltd.
Type 'rattle()' to shake, rattle, and roll your data.
Warning message:
package ‘rattle’ was built under R version 3.6.3 
> library(NbClust)
> library(psych)

Attaching package: ‘psych’

The following objects are masked from ‘package:ggplot2’:

    %+%, alpha

> 
> #based on Iris Dataset - Clustering using K means
> #by Ananya Dutta
> 
> #save graphs in pdf
> windows(7,7)
>   pdf(file="C:/Users/jmard/Desktop/Computing and Graphics in Applied Statistics2020/Output/KmeansClustering_iris_Figure.pdf")
> 
> head(iris)
  Sepal.Length Sepal.Width Petal.Length Petal.Width Species
1          5.1         3.5          1.4         0.2  setosa
2          4.9         3.0          1.4         0.2  setosa
3          4.7         3.2          1.3         0.2  setosa
4          4.6         3.1          1.5         0.2  setosa
5          5.0         3.6          1.4         0.2  setosa
6          5.4         3.9          1.7         0.4  setosa
> str(iris)
'data.frame':   150 obs. of  5 variables:
 $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...
 $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...
 $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...
 $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...
 $ Species     : Factor w/ 3 levels "setosa","versicolor",..: 1 1 1 1 1 1 1 1 1 1 ...
> describe(iris)
             vars   n mean   sd median trimmed  mad min max range  skew
Sepal.Length    1 150 5.84 0.83   5.80    5.81 1.04 4.3 7.9   3.6  0.31
Sepal.Width     2 150 3.06 0.44   3.00    3.04 0.44 2.0 4.4   2.4  0.31
Petal.Length    3 150 3.76 1.77   4.35    3.76 1.85 1.0 6.9   5.9 -0.27
Petal.Width     4 150 1.20 0.76   1.30    1.18 1.04 0.1 2.5   2.4 -0.10
Species*        5 150 2.00 0.82   2.00    2.00 1.48 1.0 3.0   2.0  0.00
             kurtosis   se
Sepal.Length    -0.61 0.07
Sepal.Width      0.14 0.04
Petal.Length    -1.42 0.14
Petal.Width     -1.36 0.06
Species*        -1.52 0.07
> 
> sapply(iris[,-5], var)  #obtain s^2 for each numeric variable
Sepal.Length  Sepal.Width Petal.Length  Petal.Width 
   0.6856935    0.1899794    3.1162779    0.5810063 
> 
> iris_scale <- scale(iris[,1:4])  #compute z scores
> 
> library(ggplot2)
> ggplot(iris,aes(x = Sepal.Length,y = Sepal.Width, color= Species)) + geom_point()
> 
> ggplot(iris,aes(x = Petal.Length,y = Petal.Width, color = Species)) + geom_point()
> 
> set.seed(1423)
> k.max <- 10
> wss<- sapply(1:k.max,function(k){kmeans(iris_scale[,3:4],k,nstart = 20,iter.max = 20)$tot.withinss})
> wss
 [1] 298.000000  53.807656  17.906783  12.201483   9.091120   7.123243
 [7]   5.954765   5.089784   4.391545   3.846710
> plot(1:k.max,wss, type= "b", xlab = "Number of clusters(k)", ylab = "Within cluster sum of squares")  #scree plot
> #choose k=3 based on the scree plot
> 
> #another choice for number of clusters is to use the NbClust library which runs
> # many experiments and gives a distribution of potential number of clusters
> 
> library(NbClust)
> #NbClust package provides 26 (documentation says 30) indices for determining the number of clusters and proposes
> # to user the best clustering scheme from the different results obtained by varying
> # all combinations of number of clusters, distance measures, and clustering methods
> 
> nc <- NbClust(iris_scale, min.nc=2, max.nc=15, method="kmeans")
*** : The Hubert index is a graphical method of determining the number of clusters.
                In the plot of Hubert index, we seek a significant knee that corresponds to a 
                significant increase of the value of the measure i.e the significant peak in Hubert
                index second differences plot. 
 
*** : The D index is a graphical method of determining the number of clusters. 
                In the plot of D index, we seek a significant knee (the significant peak in Dindex
                second differences plot) that corresponds to a significant increase of the value of
                the measure. 
 
******************************************************************* 
* Among all indices:                                                
* 10 proposed 2 as the best number of clusters 
* 6 proposed 3 as the best number of clusters 
* 1 proposed 4 as the best number of clusters 
* 1 proposed 5 as the best number of clusters 
* 3 proposed 12 as the best number of clusters 
* 1 proposed 14 as the best number of clusters 
* 2 proposed 15 as the best number of clusters 

                   ***** Conclusion *****                            
 
* According to the majority rule, the best number of clusters is  2 
 
 
******************************************************************* 
> 
> #The final model is built using kmeans and k = 3. The nstartvalue has also been defined as 20 
> #which means that R will try 20 different random starting assignments 
> #and then select the one with the lowest within cluster variation.
> 
> irisCluster <- kmeans(iris_scale[,3:4], 3, nstart = 20)
> table(irisCluster$cluster,iris$Species)
   
    setosa versicolor virginica
  1     50          0         0
  2      0          2        46
  3      0         48         4
> 
> clusplot(pam(iris_scale[,3:4],3))
> 
> q()
> dev.off()
null device 
          1 
> 
